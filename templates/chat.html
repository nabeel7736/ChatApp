<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        /* Custom Scrollbar */
        #messages::-webkit-scrollbar { width: 6px; }
        #messages::-webkit-scrollbar-track { background: transparent; }
        #messages::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 10px; }
        
        /* Message Animations */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .message-anim { animation: fadeIn 0.3s ease-out forwards; }

        /* Recording Pulse */
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .recording-pulse { animation: pulse-ring 1.5s cubic-bezier(0.25, 0.8, 0.25, 1) infinite; }

        /* Bubbles */
        .own-message .bubble { border-bottom-right-radius: 0; }
        .peer-message .bubble { border-bottom-left-radius: 0; }
        
        .own-message .bubble { cursor: context-menu; }
    </style>
</head>
<body class="bg-[#f0f2f5] h-screen flex flex-col font-sans">
    
    <header class="bg-white/80 backdrop-blur-md border-b border-gray-200 px-6 py-4 flex justify-between items-center z-20 sticky top-0 shadow-sm">
        <div class="flex items-center gap-4">
            <a href="/dashboard" class="text-gray-500 hover:text-gray-800 transition-colors">
                <i class="ph ph-arrow-left text-2xl"></i>
            </a>
            <div>
                <h2 id="roomTitle" class="text-lg font-bold text-gray-800 leading-tight">Chat Room</h2>
                <div id="connectionStatus" class="text-xs font-medium text-yellow-600 flex items-center gap-1">
                    <span class="w-2 h-2 rounded-full bg-yellow-500 animate-pulse"></span> Connecting...
                    <div id="onlineUsers" class="text-xs text-gray-500 font-medium ml-4">
    0 Online
</div>
                </div>
            </div>
        </div>
    </header>

    <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-4 relative scroll-smooth">
    </div>

    <div class="bg-white border-t border-gray-200 p-3 sm:p-4 z-20">
        <div class="container mx-auto max-w-4xl relative">
            
            <div id="editBanner" class="hidden absolute -top-12 left-0 right-0 bg-blue-50 text-blue-800 px-4 py-2 rounded-t-lg text-sm flex justify-between items-center border border-blue-100 shadow-sm">
                <span><i class="ph ph-pencil-simple mr-2"></i>Editing message...</span>
                <button onclick="cancelEdit()" class="text-blue-600 hover:text-blue-800 font-bold">âœ•</button>
            </div>

            <form id="chatForm" class="flex items-end gap-2 transition-all">
                
                <input type="file" id="fileInput" class="hidden" onchange="handleFileUpload(this)">

                <button type="button" onclick="document.getElementById('fileInput').click()" 
                    class="p-3 text-gray-500 hover:bg-gray-100 rounded-full transition-colors focus:outline-none" title="Send File/Image">
                    <i class="ph ph-plus text-xl"></i>
                </button>

                <div class="flex-1 bg-gray-100 rounded-3xl flex items-center px-4 py-2 focus-within:ring-2 focus-within:ring-blue-500 focus-within:bg-white transition-all border border-transparent focus-within:border-blue-200">
                    <textarea id="messageInput" rows="1" placeholder="Type a message..." 
                        class="w-full bg-transparent border-none focus:ring-0 resize-none max-h-32 py-2 text-gray-700 placeholder-gray-400 leading-relaxed outline-none"
                        oninput="adjustHeight(this); toggleSendButton();" 
                        onkeydown="handleEnter(event)"></textarea>
                </div>

                <div class="relative w-12 h-12 flex items-center justify-center">
                    <button type="submit" id="sendBtn" class="hidden absolute bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 shadow-lg transform hover:scale-105 transition-all">
                        <i class="ph ph-paper-plane-right text-xl"></i>
                    </button>
                    
                    <button type="button" id="recordBtn" class="absolute bg-gray-200 text-gray-600 p-3 rounded-full hover:bg-gray-300 transition-all shadow-sm">
                        <i class="ph ph-microphone text-xl"></i>
                    </button>
                </div>
            </form>

            <div id="recordingUI" class="hidden absolute inset-0 bg-white z-30 flex items-center gap-3 px-2 rounded-xl">
                <button type="button" onclick="cancelRecording()" class="p-3 text-red-500 hover:bg-red-50 rounded-full transition-colors">
                    <i class="ph ph-trash text-xl"></i>
                </button>
                
                <div class="flex-1 bg-red-50 h-12 rounded-full flex items-center px-4 gap-3 border border-red-100 relative overflow-hidden">
                    <div class="w-3 h-3 bg-red-500 rounded-full recording-pulse"></div>
                    <span id="recordTimer" class="font-mono text-red-600 font-medium">0:00</span>
                    <div class="flex-1 text-xs text-red-300 truncate">Recording audio...</div>
                </div>

                <button type="button" onclick="stopRecordingAndSend()" class="bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 shadow-lg transform hover:scale-105 transition-all">
                    <i class="ph ph-paper-plane-right text-xl"></i>
                </button>
            </div>

        </div>
    </div>

    <div id="contextMenu" class="hidden fixed bg-white border border-gray-100 shadow-xl rounded-xl py-1 z-50 w-40 overflow-hidden transform transition-all duration-200 origin-top-left">
        <button id="ctxEditBtn" class="w-full text-left px-4 py-3 text-sm hover:bg-blue-50 text-gray-700 hover:text-blue-700 font-medium flex items-center gap-3 transition-colors">
            <i class="ph ph-pencil-simple text-lg"></i> Edit
        </button>
        <button id="ctxDelBtn" class="w-full text-left px-4 py-3 text-sm hover:bg-red-50 text-gray-700 hover:text-red-600 font-medium flex items-center gap-3 transition-colors border-t border-gray-50">
            <i class="ph ph-trash text-lg"></i> Delete
        </button>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const token = localStorage.getItem('token');
        const userJson = localStorage.getItem('user');
        if (!token || !userJson) window.location.href = '/login';

        const currentUser = JSON.parse(userJson);
        const params = new URLSearchParams(window.location.search);
        const roomId = params.get('room_id');
        const roomName = params.get('room_name') || 'Chat';
        
        if (!roomId) window.location.href = '/dashboard';
        
        document.getElementById('roomTitle').innerText = roomName;

        // UI Refs
        const messagesDiv = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const recordBtn = document.getElementById('recordBtn');
        const recordingUI = document.getElementById('recordingUI');
        const recordTimer = document.getElementById('recordTimer');
        const contextMenu = document.getElementById('contextMenu');

        let ws;
        let editingMsgId = null;
        let selectedMsgId = null;
        let selectedMsgContent = null;
        let selectedMediaType = null;

        // Recording State
        let mediaRecorder;
        let audioChunks = [];
        let recordStartTime;
        let recordInterval;
        let isCancelled = false; // --- FIX 1: New flag to track cancellation ---

        // --- WEBSOCKET & CORE LOGIC ---

        function connect() {
            if (ws) {
                ws.onclose = null; 
                ws.close();
            }
            const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
            const url = `${protocol}://${location.host}/api/ws?token=${token}&room_id=${roomId}`;
            
            ws = new WebSocket(url);

            ws.onopen = () => {
                const s = document.getElementById('connectionStatus');
                s.innerHTML = '<span class="w-2 h-2 rounded-full bg-green-500"></span> Online';
                s.className = 'text-xs font-medium text-green-600 flex items-center gap-1';
            };

            ws.onmessage = (e) => {
                const data = JSON.parse(e.data);

                if (data.type === 'online_users') {
                    const count = data.users.length;
                    const onlineText = data.users.includes(currentUser.username) 
                        ? `${count} Online (You, ${data.users.filter(u => u !== currentUser.username).join(', ')})`
                        : `${count} Online`;
                        
                    const el = document.getElementById('onlineUsers');
                    if(el) el.innerText = data.users.length + " Online";
                    
                    return; 
                }

                if (data.id && document.getElementById(`msg-${data.id}`)) {
                    return;
                }

                if (data.type === 'chat') {
                    const isOwn = data.sender === currentUser.username;

                    if (!isOwn) {
                        appendMessage(data.id, data.content, false, data.sender, data.media_type, data.timestamp, data.sender_pic);
                    } else {
                        const pending = document.querySelector('.pending-msg');
                        if (pending) {
                            pending.id = `msg-${data.id}`;
                            pending.dataset.id = data.id;
                            pending.classList.remove('pending-msg', 'opacity-70');
                            
                            const bubble = pending.querySelector('.bubble-content');
                            if(bubble && data.media_type !== 'text') {
                                bubble.innerHTML = '';
                                renderMessageContent(bubble, data.content, data.media_type);
                            }
                        } else {
                            appendMessage(data.id, data.content, true, data.sender, data.media_type, data.timestamp, data.sender_pic);
                        }
                    }
                } else if (data.type === 'delete') {
                    const el = document.getElementById(`msg-${data.id}`);
                    if (el) {
                        el.style.opacity = '0';
                        el.style.transform = 'scale(0.9)';
                        setTimeout(() => el.remove(), 300);
                    }
                } else if (data.type === 'edit') {
                    const el = document.querySelector(`#msg-${data.id} .msg-text`);
                    if (el) {
                        el.innerText = data.content;
                        const editedTag = document.querySelector(`#msg-${data.id} .edited-tag`);
                        if (!editedTag) {
                            const tag = document.createElement('span');
                            tag.className = 'edited-tag text-[10px] opacity-60 ml-1 italic';
                            tag.innerText = '(edited)';
                            el.parentNode.appendChild(tag);
                        }
                    }
                }
            };

            ws.onclose = () => {
                const s = document.getElementById('connectionStatus');
                s.innerHTML = '<span class="w-2 h-2 rounded-full bg-red-500"></span> Reconnecting...';
                s.className = 'text-xs font-medium text-red-600 flex items-center gap-1';
                setTimeout(connect, 3000);
            };
        }

        async function loadHistory() {
            const res = await fetch(`/api/messages?room_id=${roomId}`, { headers: { 'Authorization': `Bearer ${token}` }});
            const data = await res.json();
            if (data.messages) {
                data.messages.forEach(msg => {
                    const isOwn = msg.sender === currentUser.username;
                    appendMessage(msg.id, msg.content, isOwn, msg.sender, msg.media_type, formatTimeRaw(msg.created_at), msg.sender_pic);
                });
            }
        }

        // --- MESSAGE RENDERING ---

        function appendMessage(id, content, isOwn, sender, mediaType = 'text', time = '', senderPic = '') {
            if (id && document.getElementById(`msg-${id}`)) return;

            const div = document.createElement('div');
            div.id = id ? `msg-${id}` : 'temp-pending';
            
            div.dataset.id = id || 0;
            div.dataset.isOwn = isOwn;
            div.dataset.mediaType = mediaType;

            const defaultAvatar = "https://ui-avatars.com/api/?name=" + (sender || 'User') + "&background=random";
            const avatarUrl = senderPic || defaultAvatar;
            
            div.className = `flex flex-col message-anim mb-4 ${isOwn ? 'items-end own-message' : 'items-start peer-message'}`;
            
            if (!id) {
                div.classList.add('pending-msg', 'opacity-70'); 
            }

            const label = !isOwn ? `<span class="text-xs text-gray-500 mb-1 ml-1 block">${sender}</span>` : '';
            const bubbleColor = isOwn ? 'bg-blue-600 text-white' : 'bg-white text-gray-800 border border-gray-100 shadow-sm';
            
           div.innerHTML = `
                <div class="flex items-end gap-2 max-w-[85%] sm:max-w-[70%] ${isOwn ? 'flex-row-reverse' : 'flex-row'}">
                    <img src="${avatarUrl}" class="w-8 h-8 rounded-full object-cover border border-gray-200 shadow-sm flex-shrink-0">
                    <div class="flex flex-col ${isOwn ? 'items-end' : 'items-start'}">
                        ${!isOwn ? `<span class="text-xs text-gray-500 mb-1 ml-1">${sender}</span>` : ''}
                        <div class="bubble bubble-content px-4 py-2 rounded-2xl ${bubbleColor} overflow-hidden">
                        </div>
                        <span class="text-[10px] text-gray-400 mt-1 mx-1">${time || 'Now'}</span>
                    </div>
                </div>
            `;

            const contentContainer = div.querySelector('.bubble-content');
            renderMessageContent(contentContainer, content, mediaType);

            messagesDiv.appendChild(div);
            scrollToBottom();
        }

        function renderMessageContent(container, content, type) {
            if (type === 'image') {
                container.classList.add('p-1');
                container.innerHTML = `<img src="${content}" class="rounded-lg max-h-64 object-cover cursor-pointer hover:opacity-95 transition" onclick="window.open(this.src)">`;
            } else if (type === 'audio') {
                container.appendChild(createAudioPlayer(content));
            } else if (type === 'file') {
                const fileName = content.split('/').pop() || 'Document';
                container.innerHTML = `
                    <a href="${content}" target="_blank" class="flex items-center gap-3 p-1 hover:underline">
                        <div class="bg-gray-100 text-gray-600 w-10 h-10 rounded-full flex items-center justify-center">
                            <i class="ph ph-file-text text-xl"></i>
                        </div>
                        <span class="truncate max-w-[150px] font-medium text-sm">${fileName}</span>
                        <i class="ph ph-download-simple"></i>
                    </a>`;
            } else {
                container.innerHTML = `<span class="msg-text whitespace-pre-wrap leading-relaxed text-sm sm:text-base">${escapeHtml(content)}</span>`;
            }
        }

        // --- AUDIO PLAYER UI ---
        function createAudioPlayer(url) {
            const wrapper = document.createElement('div');
            wrapper.className = "flex items-center gap-2 min-w-[200px] py-1";
            
            const audio = new Audio(url);
            
            const btn = document.createElement('button');
            btn.innerHTML = '<i class="ph ph-play-circle text-3xl"></i>';
            btn.className = "hover:scale-110 transition-transform focus:outline-none";
            
            const track = document.createElement('div');
            track.className = "flex-1 h-1 bg-current opacity-30 rounded-full mx-2 relative overflow-hidden";
            const progress = document.createElement('div');
            progress.className = "h-full bg-current w-0 absolute left-0 top-0";
            track.appendChild(progress);

            const time = document.createElement('span');
            time.className = "text-xs font-mono opacity-80 min-w-[30px] text-right";
            time.innerText = "0:00";

            btn.onclick = () => {
                if (audio.paused) {
                    audio.play();
                    btn.innerHTML = '<i class="ph ph-pause-circle text-3xl"></i>';
                } else {
                    audio.pause();
                    btn.innerHTML = '<i class="ph ph-play-circle text-3xl"></i>';
                }
            };

            audio.ontimeupdate = () => {
                const pct = (audio.currentTime / audio.duration) * 100;
                progress.style.width = `${pct}%`;
                time.innerText = formatDuration(audio.currentTime);
            };

            audio.onended = () => {
                btn.innerHTML = '<i class="ph ph-play-circle text-3xl"></i>';
                progress.style.width = '0%';
            };
            
            audio.onloadedmetadata = () => {
                if(isFinite(audio.duration)) time.innerText = formatDuration(audio.duration);
            };

            wrapper.append(btn, track, time);
            return wrapper;
        }

        // --- INPUT & RECORDING LOGIC ---

        function toggleSendButton() {
            const hasText = messageInput.value.trim().length > 0;
            if (hasText) {
                recordBtn.classList.add('hidden');
                sendBtn.classList.remove('hidden');
            } else {
                recordBtn.classList.remove('hidden');
                sendBtn.classList.add('hidden');
            }
        }

        function adjustHeight(el) {
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        function handleEnter(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('chatForm').dispatchEvent(new Event('submit'));
            }
        }

        // 1. File Upload Handler
        async function handleFileUpload(input) {
            const file = input.files[0];
            if (!file) return;

            let type = 'file';
            if (file.type.startsWith('image/')) type = 'image';
            if (file.type.startsWith('audio/')) type = 'audio';
            if (file.type.startsWith('video/')) type = 'file'; 

            if(type === 'image') {
                const reader = new FileReader();
                reader.onload = (e) => appendMessage(0, e.target.result, true, currentUser.username, 'image');
                reader.readAsDataURL(file);
            } else {
                appendMessage(0, `Uploading ${file.name}...`, true, currentUser.username, 'text');
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const res = await fetch('/api/upload', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData
                });
                const data = await res.json();
                
                if (data.url) {
                    ws.send(JSON.stringify({
                        type: 'chat',
                        content: data.url,
                        media_type: type
                    }));
                }
            } catch (err) {
                console.error("Upload failed", err);
                alert("File upload failed");
            }
            input.value = ''; 
        }

        // 2. Voice Recording
        recordBtn.onclick = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                isCancelled = false; // --- FIX 2: Reset cancellation flag ---
                
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                
                mediaRecorder.onstart = () => {
                    recordingUI.classList.remove('hidden');
                    recordStartTime = Date.now();
                    recordInterval = setInterval(() => {
                        const sec = Math.floor((Date.now() - recordStartTime) / 1000);
                        recordTimer.innerText = formatDuration(sec);
                    }, 1000);
                };

                mediaRecorder.onstop = async () => {
                    clearInterval(recordInterval);
                    stream.getTracks().forEach(track => track.stop());
                    
                    // --- FIX 3: Check if cancelled before sending ---
                    if (!isCancelled && audioChunks.length > 0) {
                        const blob = new Blob(audioChunks, { type: 'audio/webm' });
                        audioChunks = []; 
                        await uploadAndSendFile(blob, 'audio.webm', 'audio');
                    }
                };

                mediaRecorder.start();
            } catch (err) {
                console.error(err);
                alert("Microphone access denied or not supported.");
            }
        };

        function stopRecordingAndSend() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recordingUI.classList.add('hidden');
            }
        }

        function cancelRecording() {
            isCancelled = true; // --- FIX 4: Mark as cancelled ---
            if (mediaRecorder) {
                mediaRecorder.stop();
                audioChunks = []; 
            }
            clearInterval(recordInterval);
            recordingUI.classList.add('hidden');
        }

        async function uploadAndSendFile(blob, filename, mediaType) {
            const formData = new FormData();
            formData.append("file", blob, filename);

            appendMessage(0, URL.createObjectURL(blob), true, currentUser.username, mediaType);

            try {
                const res = await fetch('/api/upload', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` },
                    body: formData
                });
                const data = await res.json();
                if(data.url) {
                    ws.send(JSON.stringify({ type: 'chat', content: data.url, media_type: mediaType }));
                }
            } catch (e) {
                console.error("Audio upload failed", e);
            }
        }

        document.getElementById('chatForm').onsubmit = (e) => {
            e.preventDefault();
            const val = messageInput.value.trim();
            if (!val) return;

            if (editingMsgId) {
                ws.send(JSON.stringify({ type: 'edit', msg_id: parseInt(editingMsgId), content: val }));
                cancelEdit();
            } else {
                ws.send(JSON.stringify({ type: 'chat', content: val, media_type: 'text' }));
                appendMessage(0, val, true, currentUser.username, 'text'); 
            }
            
            messageInput.value = '';
            messageInput.style.height = 'auto';
            toggleSendButton();
        };

        window.onclick = (e) => {
            if (!contextMenu.contains(e.target)) contextMenu.classList.add('hidden');
        };

        messagesDiv.oncontextmenu = (e) => {
            const bubble = e.target.closest('.bubble');
            const row = e.target.closest('[id^="msg-"]');
            
            if (row && bubble && row.dataset.isOwn === "true") {
                e.preventDefault();
                const id = row.dataset.id;
                const type = row.dataset.mediaType;
                
                const canEdit = type === 'text';
                document.getElementById('ctxEditBtn').style.display = canEdit ? 'flex' : 'none';
                
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.classList.remove('hidden');

                selectedMsgId = id;
                selectedMediaType = type;
                selectedMsgContent = bubble.querySelector('.msg-text')?.innerText || "";
            }
        };

        document.getElementById('ctxDelBtn').onclick = () => {
            if (selectedMsgId && confirm("Delete this message?")) {
                ws.send(JSON.stringify({ type: 'delete', msg_id: parseInt(selectedMsgId) }));
            }
            contextMenu.classList.add('hidden');
        };

        document.getElementById('ctxEditBtn').onclick = () => {
            if (selectedMsgId && selectedMediaType === 'text') {
                editingMsgId = selectedMsgId;
                messageInput.value = selectedMsgContent;
                messageInput.focus();
                document.getElementById('editBanner').classList.remove('hidden');
                messageInput.parentElement.classList.add('ring-2', 'ring-blue-500');
            }
            contextMenu.classList.add('hidden');
        };

        function cancelEdit() {
            editingMsgId = null;
            messageInput.value = '';
            document.getElementById('editBanner').classList.add('hidden');
            messageInput.parentElement.classList.remove('ring-2', 'ring-blue-500');
            messageInput.style.height = 'auto';
        }

        function formatDuration(sec) {
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s < 10 ? '0' + s : s}`;
        }

        function formatTimeRaw(isoStr) {
            if(!isoStr) return '';
            const d = new Date(isoStr);
            return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        loadHistory();
        connect();

    </script>
</body>
</html>