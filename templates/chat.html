<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #messages::-webkit-scrollbar { width: 8px; }
        #messages::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 4px; }
        /* Prevent default context menu on own bubbles if you want strictly custom behavior */
        .own-message .bubble { cursor: context-menu; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">
    <header class="bg-white shadow p-4 flex justify-between items-center z-10">
        <div class="flex items-center">
            <a href="/dashboard" class="text-blue-600 hover:text-blue-800 mr-4 font-bold">‚Üê Back</a>
            <h2 id="roomTitle" class="text-xl font-bold text-gray-800">Chat Room</h2>
        </div>
        <div id="connectionStatus" class="text-sm font-semibold text-yellow-600">Connecting...</div>
    </header>

    <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-3 relative">
        </div>

    <div class="bg-white p-4 border-t border-gray-200">
        <form id="chatForm" class="flex gap-2 container mx-auto max-w-4xl items-center">
            <button type="button" id="cancelEditBtn" class="hidden text-gray-500 hover:text-red-600 font-medium px-3">
                Cancel
            </button>

            <button type="button" id="recordBtn" class="bg-gray-200 text-gray-700 p-3 rounded-full hover:bg-red-100 transition shadow-sm">
        üé§
    </button>
            
            <input type="text" id="messageInput" placeholder="Type a message..." class="flex-1 px-4 py-3 border rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm" autocomplete="off">
            
            <button type="submit" id="sendBtn" class="bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 shadow-md transition">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
                </svg>
            </button>
        </form>
    </div>

    <div id="contextMenu" class="hidden fixed bg-white border border-gray-200 shadow-xl rounded-lg py-1 z-50 w-32 overflow-hidden transition-opacity duration-100">
        <button id="ctxEditBtn" class="w-full text-left px-4 py-2 text-sm hover:bg-blue-50 text-blue-700 font-medium flex items-center gap-2">
            <span></span> Edit
        </button>
        <button id="ctxDelBtn" class="w-full text-left px-4 py-2 text-sm hover:bg-red-50 text-red-600 font-medium flex items-center gap-2">
            <span>√ó</span> Delete
        </button>
    </div>

    <script>
        const token = localStorage.getItem('token');
        const userJson = localStorage.getItem('user');
        if (!token || !userJson) window.location.href = '/login';

        const currentUser = JSON.parse(userJson)

        const params = new URLSearchParams(window.location.search);
        const roomId = params.get('room_id');
        const roomName = params.get('room_name') || 'Global';
        if (!roomId) {
            alert("No room ID found");
            window.location.href = '/dashboard';
        }
        document.getElementById('roomTitle').innerText = roomName;

        const statusEl = document.getElementById('connectionStatus');
        const messagesDiv = document.getElementById('messages');
        const contextMenu = document.getElementById('contextMenu');
        const messageInput = document.getElementById('messageInput');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        let ws;

        // Variables to track interaction
        let selectedMsgId = null;
        let selectedMsgContent = null;
        let editingMsgId = null;
        

        // 1. Fetch Chat History
        async function loadHistory() {
            try {
                const res = await fetch(`/api/messages?room_id=${roomId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                if(data.messages) {
                    data.messages.forEach(msg => {
                        const isOwn = msg.sender === currentUser.username;
                        appendMessage(msg.id, msg.content, isOwn, msg.sender, false, msg.media_type || "text");
                    });
                }
            } catch (err) {
                console.error("Failed to load history", err);
            }
        }

        // 2. Connect WebSocket
        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
            const url = `${protocol}://${location.host}/api/ws?token=${token}&room_id=${roomId}`;
            
            ws = new WebSocket(url);

            ws.onopen = () => {
                statusEl.innerText = 'Connected';
                statusEl.className = 'text-sm font-semibold text-green-600';
            };

           ws.onmessage = (e) => {
    try {
        const data = JSON.parse(e.data);

        if (data.type === 'delete') {
            const el = document.getElementById(`msg-${data.id}`);
            if (el) el.remove();
        } else if (data.type === 'edit') {
            const textSpan = document.querySelector(`#msg-${data.id} .msg-content`);
            if (textSpan) {
                // update content and append edited tag if not present
                textSpan.innerText = data.content;
                if (!textSpan.innerText.includes('(edited)')) {
                    textSpan.innerText += ' (edited)';
                }
            }
        } else if (data.type === 'chat') {
            if (data.sender !== currentUser.username) {
                appendMessage(data.id, data.content, false, data.sender, false, data.media_type || 'text');
            } else {
                // own message: find first pending-msg and replace its id & dataset
                const pending = document.querySelector('.pending-msg');
                if (pending) {
                    pending.id = `msg-${data.id}`;
                    pending.dataset.id = data.id;
                    pending.classList.remove('pending-msg');
                    const bubble = pending.querySelector('.bubble');
                    if (bubble) {
                        bubble.innerHTML = ''; // clear
                        if ((data.media_type || 'text') === 'audio') {
                            const audio = document.createElement('audio');
                            audio.controls = true;
                            audio.src = data.content;
                            audio.className = "w-full max-w-[200px]";
                            bubble.appendChild(audio);
                        } else {
                            const textSpan = document.createElement('span');
                            textSpan.className = 'msg-content select-text';
                            textSpan.innerText = data.content;
                            bubble.appendChild(textSpan);
                        }
                    }
                } else {
                    appendMessage(data.id, data.content, true, data.sender, false, data.media_type || 'text');
                }
            }
        }
    } catch (err) {
        console.error("Error parsing message:", err);
    }
};

            ws.onclose = () => {
                statusEl.innerText = 'Disconnected';
                statusEl.className = 'text-sm font-semibold text-red-600';
                setTimeout(connect, 5000);
            };
        }

       function editMessage(msgId, oldContent) {
            // Set state
            editingMsgId = msgId;
            
            // Populate input
            messageInput.value = oldContent;
            messageInput.focus();
            
            // Show UI indicators
            cancelEditBtn.classList.remove('hidden');
            messageInput.classList.add('ring-2', 'ring-yellow-400'); // Optional: yellow ring to indicate edit
        }
        function cancelEdit() {
            editingMsgId = null;
            messageInput.value = '';
            
            // Hide UI indicators
            cancelEditBtn.classList.add('hidden');
            messageInput.classList.remove('ring-2', 'ring-yellow-400');
        }

        function deleteMessage(msgId) {
            if(!confirm("Delete this message?")) return;
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: "delete",
                    msg_id: parseInt(msgId)
                }));
            }
        }

        // ... existing variables ...
let mediaRecorder;
let audioChunks = [];
const recordBtn = document.getElementById('recordBtn');

// 1. Handle Recording
recordBtn.onclick = async () => {
    if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        recordBtn.innerText = "üé§"; // Reset icon
        recordBtn.classList.remove("bg-red-500", "text-white", "animate-pulse");
    } else {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await uploadAndSendAudio(audioBlob);
            };

            mediaRecorder.start();
            recordBtn.innerText = "Rx"; // Recording icon
            recordBtn.classList.add("bg-red-500", "text-white", "animate-pulse");
        } catch (err) {
            console.error("Error accessing microphone:", err);
            alert("Could not access microphone");
        }
    }
};

// 2. Upload and Send function
async function uploadAndSendAudio(blob) {
    const formData = new FormData();
    formData.append("file", blob, "voice-msg.webm");

    try {
        const res = await fetch('/api/upload', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` },
            body: formData
        });
        
        if (res.ok) {
            const data = await res.json();
            ws.send(JSON.stringify({
                type: "chat",
                content: data.url,
                media_type: "audio"
            }));
            appendMessage(0, data.url, true, currentUser.username, true, "audio");

        } else {
            console.error("Upload failed");
        }
    } catch (err) {
        console.error("Error uploading audio", err);
    }
}

function appendMessage(id, text, isOwn, senderName = '', isOptimistic = false, media_type = 'text') {
    const div = document.createElement('div');

    if (isOptimistic) {
        div.id = 'temp-pending';
        div.classList.add('pending-msg');
    } else {
        div.id = `msg-${id}`;
    }

    div.dataset.id = id;
    div.dataset.isOwn = isOwn ? "true" : "false";
    div.className += ` flex flex-col ${isOwn ? 'items-end own-message' : 'items-start'} mb-2 group`;

    if (!isOwn && senderName) {
        const nameSpan = document.createElement('span');
        nameSpan.className = 'text-xs text-gray-500 mb-1 ml-1';
        nameSpan.innerText = senderName;
        div.appendChild(nameSpan);
    }

    const bubble = document.createElement('div');
    bubble.className =
        `bubble max-w-xs md:max-w-md px-4 py-3 rounded-xl shadow 
        ${isOwn ? 'bg-blue-600 text-white rounded-br-none' : 'bg-white text-gray-800 rounded-bl-none'}`;

    /* ==============================================================  
        üéß WHATSAPP AUDIO BUBBLE  
       ============================================================== */
    if (media_type === "audio") {

        const audio = new Audio(text);
        audio.preload = "metadata";

        const wrapper = document.createElement("div");
        wrapper.className = "flex items-center gap-3 w-full";

        // ‚ñ∂Ô∏è Play Button
        const playBtn = document.createElement("button");
        playBtn.innerHTML = "‚ñ∂Ô∏è";
        playBtn.className = "text-2xl focus:outline-none";

        // Waveform (Fake WhatsApp animation)
        const wave = document.createElement("div");
        wave.className = "flex-1 flex items-center gap-1";

        for (let i = 0; i < 20; i++) {
            const bar = document.createElement("div");
            bar.className = `h-${Math.floor(Math.random() * 4) + 2} w-1 bg-current opacity-70 rounded`;
            wave.appendChild(bar);
        }

        // Time text (00:00)
        const timeLabel = document.createElement("span");
        timeLabel.className = "text-xs opacity-80";
        timeLabel.innerText = "0:00";

        // Update duration when loaded
        audio.onloadedmetadata = () => {
            timeLabel.innerText = formatTime(audio.duration);
        };

        // Play/Pause Logic
        playBtn.onclick = () => {
            if (audio.paused) {
                audio.play();
                playBtn.innerHTML = "‚è∏Ô∏è";
            } else {
                audio.pause();
                playBtn.innerHTML = "‚ñ∂Ô∏è";
            }
        };

        // While playing ‚Äî update time
        audio.ontimeupdate = () => {
            timeLabel.innerText = formatTime(audio.currentTime);
        };

        // When audio ends
        audio.onended = () => {
            playBtn.innerHTML = "‚ñ∂Ô∏è";
        };

        wrapper.appendChild(playBtn);
        wrapper.appendChild(wave);
        wrapper.appendChild(timeLabel);

        bubble.appendChild(wrapper);
    }

    /* ==============================================================  
        üìù NORMAL TEXT MESSAGE  
       ============================================================== */
    else {
        const textSpan = document.createElement('span');
        textSpan.className = 'msg-content select-text';
        textSpan.innerText = text;
        bubble.appendChild(textSpan);
    }

    div.appendChild(bubble);
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

/* Format seconds ‚Üí mm:ss */
function formatTime(sec) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${s < 10 ? "0" + s : s}`;
}



        // --- Context Menu & Selection Logic ---

        function showMenu(x, y, id, content) {
            selectedMsgId = id;
            selectedMsgContent = content;
            
            // Adjust position to stay on screen
            const menuWidth = 128; // w-32 is 8rem = 128px
            if (x + menuWidth > window.innerWidth) x -= menuWidth;
            
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.remove('hidden');
        }

        function hideMenu() {
            contextMenu.classList.add('hidden');
            selectedMsgId = null;
        }

        // 1. Handle Right Click (Context Menu)
        messagesDiv.addEventListener('contextmenu', (e) => {
            const bubble = e.target.closest('.bubble');
            const msgContainer = e.target.closest('[id^="msg-"]');
            
            if (bubble && msgContainer && msgContainer.dataset.isOwn === "true") {
                e.preventDefault(); // Prevent default browser menu
                const content = bubble.querySelector('.msg-content').innerText.replace(' (edited)', '');
                showMenu(e.clientX, e.clientY, msgContainer.dataset.id, content);
            }
        });

        // 2. Handle Text Selection
        document.addEventListener('mouseup', (e) => {
            // Give a small timeout to let selection settle
            setTimeout(() => {
                const selection = window.getSelection();
                if (!selection.isCollapsed) {
                    const range = selection.getRangeAt(0);
                    // Check if selection is inside an own message
                    const container = range.commonAncestorContainer;
                    const element = container.nodeType === 1 ? container : container.parentElement;
                    const msgContainer = element.closest('[id^="msg-"]');

                    if (msgContainer && msgContainer.dataset.isOwn === "true") {
                        const rect = range.getBoundingClientRect();
                        const content = msgContainer.querySelector('.msg-content').innerText.replace(' (edited)', '');
                        // Show menu below the selection
                        showMenu(rect.left + (rect.width / 2), rect.bottom + 5, msgContainer.dataset.id, content);
                    }
                }
            }, 10);
        });

        // Hide menu on click elsewhere
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                hideMenu();
            }
        });

        // Menu Button Actions
        document.getElementById('ctxEditBtn').onclick = () => {
            if(selectedMsgId) editMessage(selectedMsgId, selectedMsgContent);
            hideMenu();
        };

        document.getElementById('ctxDelBtn').onclick = () => {
            if(selectedMsgId) deleteMessage(selectedMsgId);
            hideMenu();
        };

        document.getElementById('chatForm').onsubmit = (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            const value = input.value.trim();

            if (!value || !ws || ws.readyState !== WebSocket.OPEN) return;
            if (editingMsgId) {
                // --- HANDLE EDIT ---
                ws.send(JSON.stringify({
                    type: "edit",
                    msg_id: parseInt(editingMsgId),
                    content: value
                }));
                cancelEdit(); // Exit edit mode
            } else {
                // --- HANDLE NEW MESSAGE ---
                ws.send(JSON.stringify({
                    type: "chat",
                    content: value
                }));
                // Optimistic append
                appendMessage(0, value, true, currentUser.username, true);
                messageInput.value = '';
            }
        };
            
        loadHistory();
        connect();
    </script>
</body>
</html>